#### 一，已实现功能

将中间代码转换为MIPS32指令序列，并通过全部测试用例：

<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20221231221805160.png" alt="image-20221231221805160" style="zoom:50%;" />

**实现**：

**指令选择**：逐条将中间代码对应到目标代码上，对于不在手册示例给出的如 `a[1] = a[2]`-> `*t2 := *t1`，通过找一个空寄存器存储t，把上述代码转换为两个：`t=*t1` + `*t2 = t`。还有`x=&y` ，需要先找到y的地址，然后通过`move`指令将该地址转移即可。

**寄存器分配**：由于不考虑效率，因此选择了最简单的方法：朴素寄存器分配算法，每次在用到一个变量时，将其加载到内存中，若改变了该变量，则使用完成后再存入该地址。最大的优点是算法容易实现，缺点也显而易见，效率低，会有许多寄存器闲置，而且生成的汇编指令冗长，调试时使人眼花缭乱。寄存器的使用遵守MIPS32的约定如$a0-\$a3存放参数、\$ra存返回地址、\$v0放返回值、\$sp和\$fp作为栈指针等等。

翻译一条指令时要将一个变量加载到寄存器，先看该变量是否已经在参数寄存器中，不在的话则需从地址加载，注意参数相对于\$fp的偏移量从+8开始，局部变量从-4开始。

**栈管理**：

结合x86所学，$fp作用相当于ebp，每次进入一个函数后需要`push ebp`，即 将\$fp旧值存入栈中后，将\$sp的值赋给它。

处理完\$fp后，通过减少\$sp为该函数开辟一段空间用于存放局部变量。

函数调用前\$a0-\$a3为调用者保存，即调用前将其压栈。由于在处理IR时，`ARG`指令是反向压入参数且一次遍历难以获得参数正确的存入顺序，因此将传入的前四个参数放入寄存器，后续的参数一次压入栈中。这样的话，在被调用的函数中，前n-4个参数相对于$fp的偏移量从base=8开始依次增加4，后4个参数存依次放在\$a3-\$a0中。函数调用结束后，恢复被保存的寄存器。

<img src="C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20221227102401987.png" alt="image-20221227102401987" style="zoom: 67%;" />

**预处理**：由于需要为每个函数申请空间存储局部变量，且局部变量在函数内是通过偏移量访问的，因此需要为每个函数进行预处理，获得该函数参数个数、函数名、局部变量所占空间大小并将所有的局部变量依次串成一个链表，方便索引。

**变量的地址**：在该函数体内声明的，如图21，**规定**：**先局部变量**，**后临时变量**，用$fp+偏移量来求；如果是函数的参数，传值：直接拿来用（以\$fp-偏移量 获取其位置）；传址：该参数为其地址

#### 二，编译方法：

在 `Code` 文件夹下写有 `Makefile` 文件，通过执行 `make` 生成`parser`文件，执行 `make test` 使用 `parser` 对 `test.cmm` 文件进行词法和语法分析。也可直接通过 `bash run.sh` 命令，自动顺序执行 `make` 、`make test`、 `make clean` 三个命令。

#### 三，调试总结：

1，在程序容易出错的地方加入`assert(0);`，例如在对某一个指针解引用时使用，可提前让段错误出现

2，在各个语句块中加入类似如下语句，使得我们知道程序执行的位置，并在程序的开头决定是否定义这个宏：

```c
#ifdef DEBUG
    printf("debug: enter IR_ARG\n");
#endif 
```

3，出错时（尤其是段错误或者assert），打印出错前中间变量的值

比如查找某一个`operand`时总是找不到，打印出该变量的地址及该链表中所有变量的地址后发现，该变量的地址在整个大的地址区间中，因此猜测可能是漏插到链表了，最后发现是处理参数时指针处理不当；

某一次样例中含有循环语句时总是会出bug，恰好打印出了比较符号，猜测是代码转换出了问题，经检查发现在将中间代码转换到汇编时的对应关系整错了

4，函数嵌套调用发现存放参数的寄存器会被覆盖掉，因此每次在调用一个函数前要保存这些寄存器；结束某一个函数调用时，要把\$sp增加到原来的值，否则调用结束后栈帧无法复原等等

#### 四， 实验感想

整体而言，实验四相比前三次实验无论是从设计思路、代码量还是调试难度上都比之前有所降低，因此较为容易地就完成了本次实验。第五次实验看起来就不简单，现在主要的任务就是集中精力完成实验五了。

